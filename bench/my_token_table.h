#ifdef _MSC_VER
	#include <intrin.h>
#else
	#include <x86intrin.h>
#endif
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>

# define likely(x) __builtin_expect(!!(x), 1)
# define unlikely(x) __builtin_expect(!!(x), 0)

#ifndef BENCHMARK_MODE
/* DO NOT EDIT! generated by tokens.pl */
h2o_token_t h2o__tokens[] = {
    { { H2O_STRLIT(":authority") }, 1, 0 },
    { { H2O_STRLIT(":method") }, 2, 0 },
    { { H2O_STRLIT(":path") }, 4, 0 },
    { { H2O_STRLIT(":scheme") }, 6, 0 },
    { { H2O_STRLIT(":status") }, 8, 0 },
    { { H2O_STRLIT("accept") }, 19, 0 },
    { { H2O_STRLIT("accept-charset") }, 15, 0 },
    { { H2O_STRLIT("accept-encoding") }, 16, 0 },
    { { H2O_STRLIT("accept-language") }, 17, 0 },
    { { H2O_STRLIT("accept-ranges") }, 18, 0 },
    { { H2O_STRLIT("access-control-allow-origin") }, 20, 0 },
    { { H2O_STRLIT("age") }, 21, 0 },
    { { H2O_STRLIT("allow") }, 22, 0 },
    { { H2O_STRLIT("authorization") }, 23, 0 },
    { { H2O_STRLIT("cache-control") }, 24, 0 },
    { { H2O_STRLIT("connection") }, 0, 1 },
    { { H2O_STRLIT("content-disposition") }, 25, 0 },
    { { H2O_STRLIT("content-encoding") }, 26, 0 },
    { { H2O_STRLIT("content-language") }, 27, 0 },
    { { H2O_STRLIT("content-length") }, 28, 0 },
    { { H2O_STRLIT("content-location") }, 29, 0 },
    { { H2O_STRLIT("content-range") }, 30, 0 },
    { { H2O_STRLIT("content-type") }, 31, 0 },
    { { H2O_STRLIT("cookie") }, 32, 0 },
    { { H2O_STRLIT("date") }, 33, 1 },
    { { H2O_STRLIT("etag") }, 34, 0 },
    { { H2O_STRLIT("expect") }, 35, 0 },
    { { H2O_STRLIT("expires") }, 36, 0 },
    { { H2O_STRLIT("from") }, 37, 0 },
    { { H2O_STRLIT("host") }, 38, 0 },
    { { H2O_STRLIT("http2-settings") }, 0, 1 },
    { { H2O_STRLIT("if-match") }, 39, 0 },
    { { H2O_STRLIT("if-modified-since") }, 40, 0 },
    { { H2O_STRLIT("if-none-match") }, 41, 0 },
    { { H2O_STRLIT("if-range") }, 42, 0 },
    { { H2O_STRLIT("if-unmodified-since") }, 43, 0 },
    { { H2O_STRLIT("last-modified") }, 44, 0 },
    { { H2O_STRLIT("link") }, 45, 0 },
    { { H2O_STRLIT("location") }, 46, 0 },
    { { H2O_STRLIT("max-forwards") }, 47, 0 },
    { { H2O_STRLIT("proxy-authenticate") }, 48, 1 },
    { { H2O_STRLIT("proxy-authorization") }, 49, 1 },
    { { H2O_STRLIT("range") }, 50, 0 },
    { { H2O_STRLIT("referer") }, 51, 0 },
    { { H2O_STRLIT("refresh") }, 52, 0 },
    { { H2O_STRLIT("retry-after") }, 53, 0 },
    { { H2O_STRLIT("server") }, 54, 1 },
    { { H2O_STRLIT("set-cookie") }, 55, 0 },
    { { H2O_STRLIT("strict-transport-security") }, 56, 0 },
    { { H2O_STRLIT("transfer-encoding") }, 57, 1 },
    { { H2O_STRLIT("upgrade") }, 0, 1 },
    { { H2O_STRLIT("user-agent") }, 58, 0 },
    { { H2O_STRLIT("vary") }, 59, 0 },
    { { H2O_STRLIT("via") }, 60, 0 },
    { { H2O_STRLIT("www-authenticate") }, 61, 0 },
    { { H2O_STRLIT("x-reproxy-url") }, 0, 0 }
};
size_t h2o__num_tokens = 56;
#endif

#ifndef MIE_ALIGN
	#ifdef _MSC_VER
		#define MIE_ALIGN(x) __declspec(align(x))
	#else
		#define MIE_ALIGN(x) __attribute__((aligned(x)))
	#endif
#endif

#include <memory.h>

template<size_t len>
inline __m128i toLowerSSE_T(const char *p)
{
	enum {
		factor = 0x0101010101010101ull,
		Am1 = ('A' - 1) * factor,
		Zp1 = ('Z' + 1) * factor,
		amA = ('a' - 'A') * factor
	};
	static const MIE_ALIGN(16) uint64_t Am1Tbl[2] = { Am1, Am1 };
	static const MIE_ALIGN(16) uint64_t Zp1Tbl[2] = { Zp1, Zp1 };
	static const MIE_ALIGN(16) uint64_t amATbl[2] = { amA, amA };
	__m128i x, t0, t1;
	x = _mm_loadu_si128((const __m128i*)(p - 16 + len));
    x = _mm_srli_si128(x, 16 - len);
	t0 = _mm_cmpgt_epi8(x, *(const __m128i*)Am1Tbl);
	t1 = _mm_cmpgt_epi8(*(const __m128i*)Zp1Tbl, x);
	t0 = _mm_and_si128(t0, t1);
	t0 = _mm_and_si128(t0, *(const __m128i*)amATbl);
	x = _mm_add_epi8(x, t0);
	return x;
}

#define toLowerSSE(p, len) toLowerSSE_T<len>(p)

#ifdef __AVX2__
inline __m256i toLowerAVX(const char *p)
{
	enum {
		factor = 0x0101010101010101ull,
		Am1 = ('A' - 1) * factor,
		Zp1 = ('Z' + 1) * factor,
		amA = ('a' - 'A') * factor
	};
	static const MIE_ALIGN(16) uint64_t Am1Tbl[4] = { Am1, Am1, Am1, Am1 };
	static const MIE_ALIGN(16) uint64_t Zp1Tbl[4] = { Zp1, Zp1, Zp1, Zp1 };
	static const MIE_ALIGN(16) uint64_t amATbl[4] = { amA, amA, amA, amA };
	__m256i x, t0, t1;
	x = _mm256_loadu_si256((const __m256i*)p);
	t0 = _mm256_cmpgt_epi8(x, *(const __m256i*)Am1Tbl);
	t1 = _mm256_cmpgt_epi8(*(const __m256i*)Zp1Tbl, x);
	t0 = _mm256_and_si256(t0, t1);
	t0 = _mm256_and_si256(t0, *(const __m256i*)amATbl);
	x = _mm256_add_epi8(x, t0);
	return x;
}
#endif

inline int is_same_short_str(__m128i x, const char *key, size_t keyLen)
{
    __m128i k = _mm_loadu_si128((const __m128i*)key);
#if 0
    return !_mm_cmpestrc(x, keyLen, k, keyLen, 24);
#else
    return _mm_testc_si128(x, k);
#endif
}
/*
	does text begin with [key, keyLen)?
	ignore case of text.
	@note key must not contain [A-Z].
*/
inline int is_same_long_str(const char *text, const char *key, size_t keyLen)
{
	assert(keyLen <= 32);
#ifdef __AVX2__
	__m256i t = toLowerAVX(text);
	__m256i k = _mm256_loadu_si256((const __m256i*)key);
	return !_mm256_testc_si256(t, k);
//    return t == k;
	t = _mm256_cmpeq_epi8(t, k);
	uint64_t m = _mm256_movemask_epi8(t);
	uint64_t mask = ((uint64_t)1 << keyLen) - 1;
	return (m & mask) == mask;
#else
#if 1
	__m128i t1 = toLowerSSE(text, 16);
	__m128i k1 = _mm_loadu_si128((const __m128i*)key);
	if (!_mm_testc_si128(t1, k1)) return 0;
	__m128i t2 = toLowerSSE(text + 16, 16);
	__m128i k2 = _mm_loadu_si128((const __m128i*)(key + 16));
	return !_mm_cmpestrc(t2, keyLen - 16, k2, keyLen - 16, 8 + 16);
#else
	__m128i t1 = toLowerSSE(text, 16);
	__m128i t2 = toLowerSSE(text + 16, 16);
	__m128i k1 = _mm_loadu_si128((const __m128i*)key);
	__m128i k2 = _mm_loadu_si128((const __m128i*)(key + 16));
	t1 = _mm_cmpeq_epi8(t1, k1);
	t2 = _mm_cmpeq_epi8(t2, k2);
	uint64_t m1 = _mm_movemask_epi8(t1);
	uint64_t m2 = _mm_movemask_epi8(t2);
	m1 |= m2 << 16;
	uint64_t mask =((uint64_t)1 << keyLen) - 1;
	return (m1 & mask) == mask;
#endif
#endif
}

#ifdef BENCHMARK_MODE
const h2o_token_t *my_h2o_lookup_token(const char *name, size_t len)
#else
const h2o_token_t *h2o_lookup_token(const char *name, size_t len)
#endif
{
#define NUL16 "\0\0\0\0" "\0\0\0\0" "\0\0\0\0" "\0\0\0\0"
    const char c0 = h2o_tolower(name[0]);
	if (len <= 16) {
        __m128i v;
        switch (len) {
        case 3:
            v = toLowerSSE(name, 3);
            if (unlikely(is_same_short_str(v, "via" NUL16, 3)))
                return H2O_TOKEN_VIA;
            if (unlikely(is_same_short_str(v, "age" NUL16, 3)))
                return H2O_TOKEN_AGE;
            break;
        case 4:
            v = toLowerSSE(name, 4);
            if (unlikely(is_same_short_str(v, "date" NUL16, 4)))
                return H2O_TOKEN_DATE;
            if (unlikely(is_same_short_str(v, "etag" NUL16, 4)))
                return H2O_TOKEN_ETAG;
            if (unlikely(is_same_short_str(v, "link" NUL16, 4)))
                return H2O_TOKEN_LINK;
            if (unlikely(is_same_short_str(v, "from" NUL16, 4)))
                return H2O_TOKEN_FROM;
            if (unlikely(is_same_short_str(v, "host" NUL16, 4)))
                return H2O_TOKEN_HOST;
            if (unlikely(is_same_short_str(v, "vary" NUL16, 4)))
                return H2O_TOKEN_VARY;
            break;
        case 5:
            v = toLowerSSE(name, 5);
            if (unlikely(is_same_short_str(v, "range" NUL16, 5)))
                return H2O_TOKEN_RANGE;
            if (unlikely(is_same_short_str(v, ":path" NUL16, 5)))
                return H2O_TOKEN_PATH;
            if (unlikely(is_same_short_str(v, "allow" NUL16, 5)))
                return H2O_TOKEN_ALLOW;
            break;
        case 6:
            v = toLowerSSE(name, 6);
            if (unlikely(is_same_short_str(v, "cookie" NUL16, 6)))
                return H2O_TOKEN_COOKIE;
            if (unlikely(is_same_short_str(v, "server" NUL16, 6)))
                return H2O_TOKEN_SERVER;
            if (unlikely(is_same_short_str(v, "accept" NUL16, 6)))
                return H2O_TOKEN_ACCEPT;
            if (unlikely(is_same_short_str(v, "expect" NUL16, 6)))
                return H2O_TOKEN_EXPECT;
            break;
        case 7:
            v = toLowerSSE(name, 7);
            if (unlikely(is_same_short_str(v, ":method" NUL16, 7)))
                return H2O_TOKEN_METHOD;
            if (unlikely(is_same_short_str(v, ":scheme" NUL16, 7)))
                return H2O_TOKEN_SCHEME;
            if (unlikely(is_same_short_str(v, "upgrade" NUL16, 7)))
                return H2O_TOKEN_UPGRADE;
            if (unlikely(is_same_short_str(v, "refresh" NUL16, 7)))
                return H2O_TOKEN_REFRESH;
            if (unlikely(is_same_short_str(v, "referer" NUL16, 7)))
                return H2O_TOKEN_REFERER;
            if (unlikely(is_same_short_str(v, ":status" NUL16, 7)))
                return H2O_TOKEN_STATUS;
            if (unlikely(is_same_short_str(v, "expires" NUL16, 7)))
                return H2O_TOKEN_EXPIRES;
            break;
        case 8:
            v = toLowerSSE(name, 8);
            if (unlikely(is_same_short_str(v, "if-range" NUL16, 8)))
                return H2O_TOKEN_IF_RANGE;
            if (unlikely(is_same_short_str(v, "if-match" NUL16, 8)))
                return H2O_TOKEN_IF_MATCH;
            if (unlikely(is_same_short_str(v, "location" NUL16, 8)))
                return H2O_TOKEN_LOCATION;
            break;
        case 10:
            v = toLowerSSE(name, 10);
            if (unlikely(is_same_short_str(v, "set-cookie" NUL16, 10)))
                return H2O_TOKEN_SET_COOKIE;
            if (unlikely(is_same_short_str(v, "connection" NUL16, 10)))
                return H2O_TOKEN_CONNECTION;
            if (unlikely(is_same_short_str(v, "user-agent" NUL16, 10)))
                return H2O_TOKEN_USER_AGENT;
            if (unlikely(is_same_short_str(v, ":authority" NUL16, 10)))
                return H2O_TOKEN_AUTHORITY;
            break;
        case 11:
            v = toLowerSSE(name, 11);
            if (unlikely(is_same_short_str(v, "retry-after" NUL16, 11)))
                return H2O_TOKEN_RETRY_AFTER;
            break;
        case 12:
            v = toLowerSSE(name, 12);
            if (unlikely(is_same_short_str(v, "content-type" NUL16, 12)))
                return H2O_TOKEN_CONTENT_TYPE;
            if (unlikely(is_same_short_str(v, "max-forwards" NUL16, 12)))
                return H2O_TOKEN_MAX_FORWARDS;
            break;
        case 13:
            v = toLowerSSE(name, 13);
            if (unlikely(is_same_short_str(v, "last-modified" NUL16, 13)))
                return H2O_TOKEN_LAST_MODIFIED;
            if (unlikely(is_same_short_str(v, "content-range" NUL16, 13)))
                return H2O_TOKEN_CONTENT_RANGE;
            if (unlikely(is_same_short_str(v, "if-none-match" NUL16, 13)))
                return H2O_TOKEN_IF_NONE_MATCH;
            if (unlikely(is_same_short_str(v, "cache-control" NUL16, 13)))
                return H2O_TOKEN_CACHE_CONTROL;
            if (unlikely(is_same_short_str(v, "x-reproxy-url" NUL16, 13)))
                return H2O_TOKEN_X_REPROXY_URL;
            if (unlikely(is_same_short_str(v, "authorization" NUL16, 13)))
                return H2O_TOKEN_AUTHORIZATION;
            if (unlikely(is_same_short_str(v, "accept-ranges" NUL16, 13)))
                return H2O_TOKEN_ACCEPT_RANGES;
            break;
        case 14:
            v = toLowerSSE(name, 14);
            if (unlikely(is_same_short_str(v, "content-length" NUL16, 14)))
                return H2O_TOKEN_CONTENT_LENGTH;
            if (unlikely(is_same_short_str(v, "http2-settings" NUL16, 14)))
                return H2O_TOKEN_HTTP2_SETTINGS;
            if (unlikely(is_same_short_str(v, "accept-charset" NUL16, 14)))
                return H2O_TOKEN_ACCEPT_CHARSET;
            break;
        case 15:
            v = toLowerSSE(name, 15);
            if (unlikely(is_same_short_str(v, "accept-language", 15)))
                return H2O_TOKEN_ACCEPT_LANGUAGE;
            if (unlikely(is_same_short_str(v, "accept-encoding", 15)))
                return H2O_TOKEN_ACCEPT_ENCODING;
            break;
        case 16:
            v = toLowerSSE(name, 16);
            if (unlikely(is_same_short_str(v, "content-language", 16)))
                return H2O_TOKEN_CONTENT_LANGUAGE;
            if (unlikely(is_same_short_str(v, "www-authenticate", 16)))
                return H2O_TOKEN_WWW_AUTHENTICATE;
            if (unlikely(is_same_short_str(v, "content-encoding", 16)))
                return H2O_TOKEN_CONTENT_ENCODING;
            if (unlikely(is_same_short_str(v, "content-location", 16)))
                return H2O_TOKEN_CONTENT_LOCATION;
            break;
        default:
            return NULL;
        }
    }
    switch (len) {
    case 17:
        switch (c0) {
        case 'i':
            if (is_same_long_str(name, "if-modified-since", 17))
                return H2O_TOKEN_IF_MODIFIED_SINCE;
            break;
        case 't':
            if (is_same_long_str(name, "transfer-encoding", 17))
                return H2O_TOKEN_TRANSFER_ENCODING;
            break;
        }
        break;
    case 18:
        if (is_same_long_str(name, "proxy-authenticate", 18))
            return H2O_TOKEN_PROXY_AUTHENTICATE;
        break;
    case 19:
        switch (c0) {
        case 'i':
            if (is_same_long_str(name, "if-unmodified-since", 19))
                return H2O_TOKEN_IF_UNMODIFIED_SINCE;
            break;
        case 'c':
            if (is_same_long_str(name, "content-disposition", 19))
                return H2O_TOKEN_CONTENT_DISPOSITION;
            break;
        case 'p':
            if (is_same_long_str(name, "proxy-authorization", 19))
                return H2O_TOKEN_PROXY_AUTHORIZATION;
            break;
        }
        break;
    case 25:
        if (is_same_long_str(name, "strict-transport-security", 25))
            return H2O_TOKEN_STRICT_TRANSPORT_SECURITY;
        break;
    case 27:
        if (is_same_long_str(name, "access-control-allow-origin", 27))
            return H2O_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN;
        break;
    }
    return NULL;
}

