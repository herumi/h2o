/*
 * Copyright (c) 2014 DeNA Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/* DO NOT EDIT! generated by tokens.pl */
h2o_token_t h2o__tokens[] = {{{H2O_STRLIT(":authority")}, 1, 0, 0},
                             {{H2O_STRLIT(":method")}, 2, 0, 0},
                             {{H2O_STRLIT(":path")}, 4, 0, 0},
                             {{H2O_STRLIT(":scheme")}, 6, 0, 0},
                             {{H2O_STRLIT(":status")}, 8, 0, 0},
                             {{H2O_STRLIT("accept")}, 19, 0, 0},
                             {{H2O_STRLIT("accept-charset")}, 15, 0, 0},
                             {{H2O_STRLIT("accept-encoding")}, 16, 0, 0},
                             {{H2O_STRLIT("accept-language")}, 17, 0, 0},
                             {{H2O_STRLIT("accept-ranges")}, 18, 0, 0},
                             {{H2O_STRLIT("access-control-allow-origin")}, 20, 0, 0},
                             {{H2O_STRLIT("age")}, 21, 0, 0},
                             {{H2O_STRLIT("allow")}, 22, 0, 0},
                             {{H2O_STRLIT("authorization")}, 23, 0, 0},
                             {{H2O_STRLIT("cache-control")}, 24, 0, 0},
                             {{H2O_STRLIT("connection")}, 0, 1, 0},
                             {{H2O_STRLIT("content-disposition")}, 25, 0, 0},
                             {{H2O_STRLIT("content-encoding")}, 26, 0, 0},
                             {{H2O_STRLIT("content-language")}, 27, 0, 0},
                             {{H2O_STRLIT("content-length")}, 28, 0, 1},
                             {{H2O_STRLIT("content-location")}, 29, 0, 0},
                             {{H2O_STRLIT("content-range")}, 30, 0, 0},
                             {{H2O_STRLIT("content-type")}, 31, 0, 0},
                             {{H2O_STRLIT("cookie")}, 32, 0, 0},
                             {{H2O_STRLIT("date")}, 33, 1, 0},
                             {{H2O_STRLIT("etag")}, 34, 0, 0},
                             {{H2O_STRLIT("expect")}, 35, 0, 1},
                             {{H2O_STRLIT("expires")}, 36, 0, 0},
                             {{H2O_STRLIT("from")}, 37, 0, 0},
                             {{H2O_STRLIT("host")}, 38, 0, 1},
                             {{H2O_STRLIT("http2-settings")}, 0, 1, 0},
                             {{H2O_STRLIT("if-match")}, 39, 0, 0},
                             {{H2O_STRLIT("if-modified-since")}, 40, 0, 0},
                             {{H2O_STRLIT("if-none-match")}, 41, 0, 0},
                             {{H2O_STRLIT("if-range")}, 42, 0, 0},
                             {{H2O_STRLIT("if-unmodified-since")}, 43, 0, 0},
                             {{H2O_STRLIT("last-modified")}, 44, 0, 0},
                             {{H2O_STRLIT("link")}, 45, 0, 0},
                             {{H2O_STRLIT("location")}, 46, 0, 0},
                             {{H2O_STRLIT("max-forwards")}, 47, 0, 0},
                             {{H2O_STRLIT("proxy-authenticate")}, 48, 1, 0},
                             {{H2O_STRLIT("proxy-authorization")}, 49, 1, 0},
                             {{H2O_STRLIT("range")}, 50, 0, 0},
                             {{H2O_STRLIT("referer")}, 51, 0, 0},
                             {{H2O_STRLIT("refresh")}, 52, 0, 0},
                             {{H2O_STRLIT("retry-after")}, 53, 0, 0},
                             {{H2O_STRLIT("server")}, 54, 1, 0},
                             {{H2O_STRLIT("set-cookie")}, 55, 0, 0},
                             {{H2O_STRLIT("strict-transport-security")}, 56, 0, 0},
                             {{H2O_STRLIT("transfer-encoding")}, 57, 1, 1},
                             {{H2O_STRLIT("upgrade")}, 0, 1, 1},
                             {{H2O_STRLIT("user-agent")}, 58, 0, 0},
                             {{H2O_STRLIT("vary")}, 59, 0, 0},
                             {{H2O_STRLIT("via")}, 60, 0, 0},
                             {{H2O_STRLIT("www-authenticate")}, 61, 0, 0},
                             {{H2O_STRLIT("x-reproxy-url")}, 0, 0, 0}};
size_t h2o__num_tokens = 56;

static inline uint64_t local_get1(const char *p)
{
  return (uint8_t)*p;
}
static inline uint64_t local_get2(const char *p)
{
  uint16_t r;
  memcpy(&r, p, 2);
  return r;
}
static inline uint64_t local_get3(const char *p)
{
  return local_get2(p) | (local_get1(p + 2) << 16);
}
static inline uint64_t local_get4(const char *p)
{
  uint32_t r;
  memcpy(&r, p, 4);
  return r;
}
static inline uint64_t local_get5(const char *p)
{
  return local_get4(p) | (local_get1(p + 4) << 32);
}
static inline uint64_t local_get6(const char *p)
{
  return local_get4(p) | (local_get2(p + 4) << 32);
}
static inline uint64_t local_get7(const char *p)
{
  return local_get4(p) | (local_get3(p + 4) << 32);
}
static inline uint64_t local_get8(const char *p)
{
  uint64_t r;
  memcpy(&r, p, 8);
  return r;
}
static inline uint64_t local_cmp1(const char *p, const char *q) { return local_get1(p) ^ local_get1(q); }
static inline uint64_t local_cmp2(const char *p, const char *q) { return local_get2(p) ^ local_get2(q); }
static inline uint64_t local_cmp3(const char *p, const char *q) { return local_get3(p) ^ local_get3(q); }
static inline uint64_t local_cmp4(const char *p, const char *q) { return local_get4(p) ^ local_get4(q); }
static inline uint64_t local_cmp5(const char *p, const char *q) { return local_get5(p) ^ local_get5(q); }
static inline uint64_t local_cmp6(const char *p, const char *q) { return local_get6(p) ^ local_get6(q); }
static inline uint64_t local_cmp7(const char *p, const char *q) { return local_get7(p) ^ local_get7(q); }
static inline uint64_t local_cmp8(const char *p, const char *q) { return local_get8(p) ^ local_get8(q); }
static inline uint64_t local_cmp9(const char *p, const char *q)  { return local_cmp8(p, q) | local_cmp1(p + 8, q + 8); }
static inline uint64_t local_cmp10(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp2(p + 8, q + 8); }
static inline uint64_t local_cmp11(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp3(p + 8, q + 8); }
static inline uint64_t local_cmp12(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp4(p + 8, q + 8); }
static inline uint64_t local_cmp13(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp5(p + 8, q + 8); }
static inline uint64_t local_cmp14(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp6(p + 8, q + 8); }
static inline uint64_t local_cmp15(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp7(p + 8, q + 8); }
static inline uint64_t local_cmp16(const char *p, const char *q) { return local_cmp8(p, q) | local_cmp8(p + 8, q + 8); }
static inline uint64_t local_cmp17(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp1(p + 16, q + 16); }
static inline uint64_t local_cmp18(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp2(p + 16, q + 16); }
static inline uint64_t local_cmp19(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp3(p + 16, q + 16); }
static inline uint64_t local_cmp20(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp4(p + 16, q + 16); }
static inline uint64_t local_cmp21(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp5(p + 16, q + 16); }
static inline uint64_t local_cmp22(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp6(p + 16, q + 16); }
static inline uint64_t local_cmp23(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp7(p + 16, q + 16); }
static inline uint64_t local_cmp24(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp8(p + 16, q + 16); }
static inline uint64_t local_cmp25(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp9(p + 16, q + 16); }
static inline uint64_t local_cmp26(const char *p, const char *q) { return local_cmp16(p, q) | local_cmp10(p + 16, q + 16); }

static inline uint64_t my_memcmp(const void *p1, const void *p2, size_t n)
{
  const char *p = (const char *)p1;
  const char *q = (const char *)p2;
  switch (n) {
  case 0: return 1;
  case 1: return local_cmp1(p, q);
  case 2: return local_cmp2(p, q);
  case 3: return local_cmp3(p, q);
  case 4: return local_cmp4(p, q);
  case 5: return local_cmp5(p, q);
  case 6: return local_cmp6(p, q);
  case 7: return local_cmp7(p, q);
  case 8: return local_cmp8(p, q);
  case 9: return local_cmp9(p, q);
  case 10: return local_cmp10(p, q);
  case 11: return local_cmp11(p, q);
  case 12: return local_cmp12(p, q);
  case 13: return local_cmp13(p, q);
  case 14: return local_cmp14(p, q);
  case 15: return local_cmp15(p, q);
  case 16: return local_cmp16(p, q);
  case 17: return local_cmp17(p, q);
  case 18: return local_cmp18(p, q);
  case 19: return local_cmp19(p, q);
  case 20: return local_cmp20(p, q);
  case 21: return local_cmp21(p, q);
  case 22: return local_cmp22(p, q);
  case 23: return local_cmp23(p, q);
  case 24: return local_cmp24(p, q);
  case 25: return local_cmp25(p, q);
  case 26: return local_cmp26(p, q);
  default: return memcmp(p, q, n);
  }
}

const h2o_token_t *h2o_lookup_token(const char *name, size_t len)
{
    switch (len) {
    case 3:
        switch (name[2]) {
        case 'a':
            if (my_memcmp(name, "vi", 2) == 0)
                return H2O_TOKEN_VIA;
            break;
        case 'e':
            if (my_memcmp(name, "ag", 2) == 0)
                return H2O_TOKEN_AGE;
            break;
        }
        break;
    case 4:
        switch (name[3]) {
        case 'e':
            if (my_memcmp(name, "dat", 3) == 0)
                return H2O_TOKEN_DATE;
            break;
        case 'g':
            if (my_memcmp(name, "eta", 3) == 0)
                return H2O_TOKEN_ETAG;
            break;
        case 'k':
            if (my_memcmp(name, "lin", 3) == 0)
                return H2O_TOKEN_LINK;
            break;
        case 'm':
            if (my_memcmp(name, "fro", 3) == 0)
                return H2O_TOKEN_FROM;
            break;
        case 't':
            if (my_memcmp(name, "hos", 3) == 0)
                return H2O_TOKEN_HOST;
            break;
        case 'y':
            if (my_memcmp(name, "var", 3) == 0)
                return H2O_TOKEN_VARY;
            break;
        }
        break;
    case 5:
        switch (name[4]) {
        case 'e':
            if (my_memcmp(name, "rang", 4) == 0)
                return H2O_TOKEN_RANGE;
            break;
        case 'h':
            if (my_memcmp(name, ":pat", 4) == 0)
                return H2O_TOKEN_PATH;
            break;
        case 'w':
            if (my_memcmp(name, "allo", 4) == 0)
                return H2O_TOKEN_ALLOW;
            break;
        }
        break;
    case 6:
        switch (name[5]) {
        case 'e':
            if (my_memcmp(name, "cooki", 5) == 0)
                return H2O_TOKEN_COOKIE;
            break;
        case 'r':
            if (my_memcmp(name, "serve", 5) == 0)
                return H2O_TOKEN_SERVER;
            break;
        case 't':
            if (my_memcmp(name, "accep", 5) == 0)
                return H2O_TOKEN_ACCEPT;
            if (my_memcmp(name, "expec", 5) == 0)
                return H2O_TOKEN_EXPECT;
            break;
        }
        break;
    case 7:
        switch (name[6]) {
        case 'd':
            if (my_memcmp(name, ":metho", 6) == 0)
                return H2O_TOKEN_METHOD;
            break;
        case 'e':
            if (my_memcmp(name, ":schem", 6) == 0)
                return H2O_TOKEN_SCHEME;
            if (my_memcmp(name, "upgrad", 6) == 0)
                return H2O_TOKEN_UPGRADE;
            break;
        case 'h':
            if (my_memcmp(name, "refres", 6) == 0)
                return H2O_TOKEN_REFRESH;
            break;
        case 'r':
            if (my_memcmp(name, "refere", 6) == 0)
                return H2O_TOKEN_REFERER;
            break;
        case 's':
            if (my_memcmp(name, ":statu", 6) == 0)
                return H2O_TOKEN_STATUS;
            if (my_memcmp(name, "expire", 6) == 0)
                return H2O_TOKEN_EXPIRES;
            break;
        }
        break;
    case 8:
        switch (name[7]) {
        case 'e':
            if (my_memcmp(name, "if-rang", 7) == 0)
                return H2O_TOKEN_IF_RANGE;
            break;
        case 'h':
            if (my_memcmp(name, "if-matc", 7) == 0)
                return H2O_TOKEN_IF_MATCH;
            break;
        case 'n':
            if (my_memcmp(name, "locatio", 7) == 0)
                return H2O_TOKEN_LOCATION;
            break;
        }
        break;
    case 10:
        switch (name[9]) {
        case 'e':
            if (my_memcmp(name, "set-cooki", 9) == 0)
                return H2O_TOKEN_SET_COOKIE;
            break;
        case 'n':
            if (my_memcmp(name, "connectio", 9) == 0)
                return H2O_TOKEN_CONNECTION;
            break;
        case 't':
            if (my_memcmp(name, "user-agen", 9) == 0)
                return H2O_TOKEN_USER_AGENT;
            break;
        case 'y':
            if (my_memcmp(name, ":authorit", 9) == 0)
                return H2O_TOKEN_AUTHORITY;
            break;
        }
        break;
    case 11:
        switch (name[10]) {
        case 'r':
            if (my_memcmp(name, "retry-afte", 10) == 0)
                return H2O_TOKEN_RETRY_AFTER;
            break;
        }
        break;
    case 12:
        switch (name[11]) {
        case 'e':
            if (my_memcmp(name, "content-typ", 11) == 0)
                return H2O_TOKEN_CONTENT_TYPE;
            break;
        case 's':
            if (my_memcmp(name, "max-forward", 11) == 0)
                return H2O_TOKEN_MAX_FORWARDS;
            break;
        }
        break;
    case 13:
        switch (name[12]) {
        case 'd':
            if (my_memcmp(name, "last-modifie", 12) == 0)
                return H2O_TOKEN_LAST_MODIFIED;
            break;
        case 'e':
            if (my_memcmp(name, "content-rang", 12) == 0)
                return H2O_TOKEN_CONTENT_RANGE;
            break;
        case 'h':
            if (my_memcmp(name, "if-none-matc", 12) == 0)
                return H2O_TOKEN_IF_NONE_MATCH;
            break;
        case 'l':
            if (my_memcmp(name, "cache-contro", 12) == 0)
                return H2O_TOKEN_CACHE_CONTROL;
            if (my_memcmp(name, "x-reproxy-ur", 12) == 0)
                return H2O_TOKEN_X_REPROXY_URL;
            break;
        case 'n':
            if (my_memcmp(name, "authorizatio", 12) == 0)
                return H2O_TOKEN_AUTHORIZATION;
            break;
        case 's':
            if (my_memcmp(name, "accept-range", 12) == 0)
                return H2O_TOKEN_ACCEPT_RANGES;
            break;
        }
        break;
    case 14:
        switch (name[13]) {
        case 'h':
            if (my_memcmp(name, "content-lengt", 13) == 0)
                return H2O_TOKEN_CONTENT_LENGTH;
            break;
        case 's':
            if (my_memcmp(name, "http2-setting", 13) == 0)
                return H2O_TOKEN_HTTP2_SETTINGS;
            break;
        case 't':
            if (my_memcmp(name, "accept-charse", 13) == 0)
                return H2O_TOKEN_ACCEPT_CHARSET;
            break;
        }
        break;
    case 15:
        switch (name[14]) {
        case 'e':
            if (my_memcmp(name, "accept-languag", 14) == 0)
                return H2O_TOKEN_ACCEPT_LANGUAGE;
            break;
        case 'g':
            if (my_memcmp(name, "accept-encodin", 14) == 0)
                return H2O_TOKEN_ACCEPT_ENCODING;
            break;
        }
        break;
    case 16:
        switch (name[15]) {
        case 'e':
            if (my_memcmp(name, "content-languag", 15) == 0)
                return H2O_TOKEN_CONTENT_LANGUAGE;
            if (my_memcmp(name, "www-authenticat", 15) == 0)
                return H2O_TOKEN_WWW_AUTHENTICATE;
            break;
        case 'g':
            if (my_memcmp(name, "content-encodin", 15) == 0)
                return H2O_TOKEN_CONTENT_ENCODING;
            break;
        case 'n':
            if (my_memcmp(name, "content-locatio", 15) == 0)
                return H2O_TOKEN_CONTENT_LOCATION;
            break;
        }
        break;
    case 17:
        switch (name[16]) {
        case 'e':
            if (my_memcmp(name, "if-modified-sinc", 16) == 0)
                return H2O_TOKEN_IF_MODIFIED_SINCE;
            break;
        case 'g':
            if (my_memcmp(name, "transfer-encodin", 16) == 0)
                return H2O_TOKEN_TRANSFER_ENCODING;
            break;
        }
        break;
    case 18:
        switch (name[17]) {
        case 'e':
            if (my_memcmp(name, "proxy-authenticat", 17) == 0)
                return H2O_TOKEN_PROXY_AUTHENTICATE;
            break;
        }
        break;
    case 19:
        switch (name[18]) {
        case 'e':
            if (my_memcmp(name, "if-unmodified-sinc", 18) == 0)
                return H2O_TOKEN_IF_UNMODIFIED_SINCE;
            break;
        case 'n':
            if (my_memcmp(name, "content-dispositio", 18) == 0)
                return H2O_TOKEN_CONTENT_DISPOSITION;
            if (my_memcmp(name, "proxy-authorizatio", 18) == 0)
                return H2O_TOKEN_PROXY_AUTHORIZATION;
            break;
        }
        break;
    case 25:
        switch (name[24]) {
        case 'y':
            if (my_memcmp(name, "strict-transport-securit", 24) == 0)
                return H2O_TOKEN_STRICT_TRANSPORT_SECURITY;
            break;
        }
        break;
    case 27:
        switch (name[26]) {
        case 'n':
            if (my_memcmp(name, "access-control-allow-origi", 26) == 0)
                return H2O_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN;
            break;
        }
        break;
    }

    return NULL;
}
